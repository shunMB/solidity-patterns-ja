# Guard Check

## 目的

スマートコントラクトの振る舞いと入力パラメータを保証する。


## 動機

通常の法的契約と同様に、スマートコントラクトでもよくあることですが、契約ロジックは特定の要件が満たされた後に初めて有効になると想定されています。例えば、遺産は遺言者が死亡した後に相続人に支払われるべきです。
実社会には弁護士や公証人がいますが、スマートコントラクトには規制当局や調停人はいません。そこで、スマートコントラクトロジックが指定した通りに機能していることを確認するために、ある種の警備員や小切手のようなものが必要です。

スマートコントラクトに望まれる振る舞いは、要求されたすべてのことをチェックし、それらが意図したものであるならば実行するということでしょう。また、なんらかのバグや欠陥がある場合、契約はその状態に行われたすべての変更を元に戻すことが望まれます。
これを行うために、SolidityはEVMがエラーを処理する方法を利用しています。EVMはアトミック性を維持するために、すべての変更は元に戻され、トランザクション全体は無効になります。
Solidityはこれらのエラーを引き起こして状態を元に戻すために例外を使用しています。そして、そのような例外を引き起こすためにSolidityにはいくつかの方法があります。このパターンはそれらの違いを記述し、それらのそれぞれをどのようにそしていつ使うべきかについて考えていきます。


## 適用範囲

Guard Checkパターンを使用できるのは、
* ユーザーが入力したパラメーターを検証する場合
* コントラクトロジックを実行する前にコントラクトの状態をチェックする場合
* コード内の不変条件をチェックする場合
* 使用可能にすべきでない条件式を除外する場合
です。


## 想定するコントラクトの参加者

このパターンを使用してユーザーが送信したデータや他の契約から返されたデータを検証できますが、すべての動作は内部的に実行されるため、唯一の参加者は実装契約そのものです。


## 実装

Solidityバージョン0.4.10より前では、要件が満たされない場合に例外を投げるif文を使ってチェックが一般的に実装されていました：
`if(testator != deceased) { throw; }` 。しかし、0.4.13以降では `throw` は廃止となり、代わりに次の3つの関数の使用が推奨されています： `revert()`, `require()` and `assert()` 。このセクションでは、それらのうちどれを使用していつ例外をトリガーするかを説明します。

ビサンチウムのアップデート以前は`require（）`と `assert（）`は同じ振る舞いをしていました。ですがビサンチウム以来、この2つの関数のオペコードは違うものになりました。 2つのメソッド `require（）`と `revert（）`は `0xfd`（` REVERT`）を使い、 `assert（）`は `0xfe`（` INVALID`）を使います。 2つのオペコードの大きな違いはガスリターンにあります。 「REVERT」は例外がスローされた時点で消費されていないすべてのガスを返金していますが、「INVALID」はトランザクションに含まれるすべてのガスを使い果たします。この違いは念頭に置いておくべきであり、すでにどのような状況が意図されているのかを示しています。

[Solidityドキュメント](http://solidity.readthedocs.io/en/v0.4.21/#)では、入力値やコントラクトの状態変数、妥当な条件式であることを保証するため、あるいは外部規約への呼び出しからの戻り値を検証するために`require()`を使用するべきだと述べています。また、内部エラーをテストする際と、定数をチェックするために`assert()`を使用するべきだと述べています。両方のメソッドとも、渡されたパラメータをブール値として評価し、評価結果が `false`の場合は例外をスローします。どんな場合でも `revert（）`は投げます。そのため、if-elseツリーのように、1行のコードで条件の評価を実行できず、 `require()`の使用が適していないような複雑な状況で役立ちます。

一般的に、`require()`はバリデーションのために関数の始めに向かって使われるべきで、他の二つよりももっと頻繁に使われるべきです。
`assert()`メソッドは関数の最後に使用され、重大なエラーを防ぐためだけに使用されるべきです。
通常の状況下やバグフリーなコードにおいて、`assert()`文は決して`true`と評価されるべきではありません。

[Solidityバージョン0.4.22](https://solidity.readthedocs.io/en/v0.4.22/units-and-global-variables.html#error-handling)以降、 `require(bool condition, string message)`と`revert(string message)`にエラーメッセージを加えることが可能になりました。


## サンプルコード

この架空のサンプルコントラクトは寄付の分配者(= distributor)です。ユーザーは彼らがサポートしたい慈善団体のアドレスと寄付をイーサリアムで送ります。慈善団体のアドレスにイーサリアムがない場合は、全額が送金されます。彼らがすでにいくらかのイーサリアムを所有しているが寄付者よりも少ない場合、寄付額の半分は他の半分が将来の分配のためのコントラクトに留まる一方で転送されます（簡潔さのために実装されていません）。慈善団体が寄付者より多くの資金を持っている場合は、寄付するべきではありません。このサンプルコントラクトは、Check Guardパターンを実装するための3つの可能性すべてを示しています。
```Solidity
// This code has not been professionally audited, therefore I cannot make any promises about
// safety or correctness. Use at own risk.
contract GuardCheck {
    
    function donate(address addr) payable public {
        require(addr != address(0));
        require(msg.value != 0);
        uint balanceBeforeTransfer = this.balance;
        uint transferAmount;
        
        if (addr.balance == 0) {
            transferAmount = msg.value;
        } else if (addr.balance < msg.sender.balance) {
            transferAmount = msg.value / 2;
        } else {
            revert();
        }
        
        addr.transfer(transferAmount);
        assert(this.balance == balanceBeforeTransfer - transferAmount);      
    }
}
```
4行目の `require`文で、ユーザーが慈善団体を指定するのを忘れた場合のように、ユーザーによって提供されたアドレスがゼロではないことを確認します。 5行目で、ユーザーが自分の取引に寄付をしたかどうかを確認します。そうでない場合は、すぐに停止できます。 9行目から始まるif-else文は、チャリティーの現在の残高に応じて、チャリティーに送る金額を決定します。慈善団体が寄付者よりも多くのイーサリアムを持っている場合、14行目の「元に戻す」は、お金が移転されないことを確実にし、機能は元に戻されます。 17行目で、寄付は慈善団体に送られます。 18行目の最後の`assert`文は、寄付後の現在の残高が、寄付前の残高から寄付額を引いたものに等しいことを保証します。通常の状況下では、これは常に `true`と評価されるべきです。これが事実に当てはまらない場合、慈善団体への寄付の送金を含む取引全体が元に戻されます。


## 結論

Guard Checkパターンを適用する際の良いことの1つは、可読性の向上です。 if/throw構成と比較して、 `require`関数の使用はエンジニアではない読者が操作の意図を理解することをより簡単にします。さらに、この新しい表現は一般的にきれいです。いくつかの選択肢があることの別の利点は、個々の方法が将来の機能を実装する際、それらの目的に合わせることが可能になることです。前述のように、 `revert（）`と `require（）`メソッドはエラーメッセージを備えていましたが、 `assert（）`は静的解析や形式的検証のような手法を用いた評価を目的として使用でき、コントラクトロジックを破綻させる条件を識別できます。これら３つの異なるメソッドが使用可能であることは、様々な状況下におけるアプリケーション開発を可能にし、そのため開発者に柔軟性を提供します。

このパターンで実装を行った経験のないユーザーにとって、これらのメソッドは混乱のもとになるなるかもしれません。
なぜなら名前が似通っているにもかかわらず、どこが違うのかについて説明を行っていないからです。
間違ったメソッドを使用することは望まれない振る舞いを引き起こします。ユーザーが関数の引数に入力ミスをした場合にガスをすべて失うなどといったことです。

Guard Checkはエラーを処理し、望ましくない動作から保護するための信頼できる方法を提供します。そのため、Access Restriction pattern](https://github.com/shunMB/solidity-patterns-ja/access_restriction.html) では重要な要素となっています。


## 既知の使われ方

このパターンは公開されているほぼすべてのコントラクトに適用されています。イーサリアムを保持するインセンティブを与えることを目的としたトークンである、[HODLit](https://etherscan.io/address/0x24021d38DB53A938446eCB0a31B1267764d9d63D)は良い例です。
なぜなら3つすべてのメソッドを実装しているからです。`require` はメソッドの先頭のチェックに使われ、`assert`は演算過程でオーバーフロー/アンダーフローを起こさないように使われます。そして`revert`は269行目のfallback関数内でコールされ、故意に特定の関数をコールすることなくイーサリアムをコントラクトに送金することを防ぎます。

悪い例はこの[カジノコントラクト](https://github.com/merlox/casino-ethereum/blob/master/contracts/Casino.sol)で見ることができます。この開発者は`assert`をコントラクト内のすべてのチェックに使用しています。これでは1つでもチェックが失敗したときにすべてのガスを失うことになりかねません。ユーザーが自分の取引がガス不足にならないようにして非常に高いガスリミットを設定した場合、これはかなりの金額の損失をもたらす可能性があります。

[**< 戻る**](https://github.com/shunMB/solidity-patterns-ja/)
