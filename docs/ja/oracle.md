# Oracle

## 目的

ブロックチェーン外のデータにアクセスする。


## 動機

イーサリアムブロックチェーンのすべての計算は、ネットワークに参加しているすべてのノードによって検証される必要があります。すべてのノードがその結果を検証するために自分自身でその要求を行わなければならないため、契約からのあらゆる種類の外部ネットワーク要求を許可することは現実的ではありません。これは、小規模サイトでは処理できない可能性がある過剰なネットワーク使用率につながるだけでなく、要求された情報の変更によって合意アルゴリズムが破られる可能性もあります。したがって、ブロックチェーンコントラクト自体は外部と通信することができません。つまり、インターネットのような情報源から情報を引き出すことはできません。
しかし、多くのコントラクトにおいて、特に業界がより複雑なユースケースを探していることから、外部イベントに関する情報がその中心的な目的を果たすために必要になります。スポーツイベントの結果、通貨の価格、またはフライトの状況に関する情報に依存するコントラクトはすでにあります。

この制限を克服するための最初の解決策の1つは、2014年に公開されたサービス[Orisi](https://github.com/orisi/wiki/wiki/Orisi-White-Paper)でした。これはBitcoinブロックチェーンと外部の間の仲介者になることを目的としていました。
以来、オラクルという言葉の下に、似たような概念を持つさまざまなブロックチェーンに対するいくつかのサービスが登場しました。オラクルは、ブロックチェーン上に存在し、クエリーに対する応答の形で情報を提供するエージェントとして機能します。
ブロックチェーンのコンテキストでデータを処理する際の重要な点は信頼の概念です。中心的な権威がないので、信頼は不変性や実用的なコンセンサスアルゴリズムのような概念から構築されなければなりません。外部から導入された情報に頼るとき、その情報に対する信頼を築く方法を見つけることも必要です。


## 適用範囲

Oracleパターンを使用できるのは、
* ブロックチェーン外から提供されるデータを信頼する場合
* サービスに必要なデータの提供者を信用する場合
です。


## 想定するコントラクトの参加者

オラクルパターンは、データをリクエストするコントラクト、そのオラクル、およびデータソースの3つのエンティティで構成されています。このプロセスは、データをリクエストするコントラクトから始まります。コントラクト自身はブロックチェーン内からデータを取得できません。したがって、トランザクションはオラクルコントラクトに送信されます。オラクルコントラクトはブロックチェーンにも存在します。この取引は、契約が履行されることをリクエストに含みます。オプションのパラメータは、回答が配信される必要なデータソース、または将来の特定の時間に設定することができます。
その後、オラクルはリクエストを合意されたデータソースに転送します。データソースはチェーン外なので、この通信はブロックチェーントランザクションを介してではなく、他の形式のデジタル通信を介して行われます。
リクエストがデータソースに到達すると処理され、返信がオラクルに返送されます。そこからオラクルはそれを要求している連絡先に送り返すか、リクエストに記載された時間まで待機します。最初のコントラクトは関数呼び出しを介してデータを受け取り、そこでそのコントラクトはデータに対して任意のロジックを実行することができます。


## 実装

このセクションでは、リクエスト側のコントラクトにおけるオラクルパターンの実装にのみ焦点を当てます。オラクルの実装自体は主にチェーン外で行われるため、ここでは説明しません。スマートコントラクトとあなたのビジネスモデルのためにカスタマイズされたオラクルをどのように実装するかを説明する情報はインターネット上にたくさんあります。ただし、自己提供データが契約ロジックの実行に使用されていることを確認することで、あなたの契約と対話することを考えている人は見逃してしまうかもしれません。このシナリオでは、データソースから契約までの間にデータを操作しないようにするために、コントラクトオーナーは、Oracleのオペレータと同じエンティティであることを信頼する必要があります。これは信頼の必要性を再導入するもので、私たちはブロックチェーンを使ってそれを取り除こうとします。

これに代わるより一般的に使用されている方法は、オラクルとして独立したサービスを使用することです。現時点でこのドメインのマーケットリーダーは英国の会社[Oraclize](https://docs.oraclize.it/)です。他のオラクルサービスは、例えば、[Town Crier](http://www.town-crier.org/)や、信頼できるハードウェアウェアとともにオラクルを提供する[Reality Keys](https://www.realitykeys.com/)などです。

Oracleが自前で実装されているか外部サービスが使用されているかにかかわらず、リクエスト側のスマートコントラクトは少なくとも以下の2つの方法を実装する必要があります。
1. 最初の方法では、問合せを組み立てて、どのデータが要求されているかをオラクルに知らせ、それをトランザクションでオラクルコントラクトに送信します。 オラクルの実装に応じて、追加のパラメータをリクエストに追加できます。一般に、オラクルはその後参照用に保管できるIDを返します。
2. 2番目の方法は、いわゆるコールバック関数です。これは、問合せの結果を配信するためにオラクルコントラクトによって呼び出される関数です。コールバック関数は、クエリの結果を格納するか、または内部ロジックを起動します。着信コールは、最初のメソッドで返されたIDによって関連付けることができます。 オラクルだけがそれを呼び出すことができることを確認するためにコールバック関数にチェックを含めることは理にかなっています。そうでなければ、悪意のあるエンティティが間違った情報を提供して、その情報から害を受けたり利益を得たりすることができます。


## サンプルコード

Oraclizeは、オラクルが必要とされるほとんどの場合に使用されるため、次のサンプルでは、​​現在のEURからUSDの為替レートを受け取るためにOraclizeオラクルと対話するために必要なコードを紹介します。他のオラクルも同様の方法で統合されています。必要な正確な構文に関する情報はそれぞれのドキュメントを参照してください。

```Solidity
// This code has not been professionally audited, therefore I cannot make any promises about
// safety or correctness. Use at own risk.
import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";

contract OracleExample is usingOraclize {

    string public EURUSD;

    function updatePrice() public payable {
        if (oraclize_getPrice("URL") > this.balance) {
            //Handle out of funds error
        } else {
            oraclize_query("URL", "json(http://api.fixer.io/latest?symbols=USD).rates.USD");
        }
    }
    
    function __callback(bytes32 myid, string result) public {
        require(msg.sender == oraclize_cbAddress());
        EURUSD = result;
    }
}
```
2行目でOraclizeのAPIがGitHubからインポートされています。コンパイラがGitHubのようなソースからの直接インポートをサポートしていない場合は、importステートメントをAPIのローカルインポートに置き換える必要があります。 APIは、アドレスへのアクセスと、Oracleとの対話に必要な機能を提供するために必要です。 4行目では、キーワードisを使用してコントラクトがAPIから継承されるように指定されています。関数 `updatePrice()`は、クエリをOracleに送信しています。 `payable`修飾子が使われています。これはトランザクションに値（ある量のEther）を送金することを可能にします。 Oraclizeサービスの使用は無料ではないため、これは必要です。料金は[Oraclizeドキュメント](https://docs.oraclize.it/)にあります。 9行目は、コントラクトにサービスの支払いに十分な資金があると主張しています。そうでない場合、例えばイベントをトリガすることによって、ユーザに通知されるべきである。残高が十分であれば、クエリは12行目でOraclizeコントラクトに送信されます。最初のパラメータはURLをクエリすることをOracleに伝え、2番目のパラメータはAPIのURLと米ドル情報を含んだレスポンスJSONオブジェクトの一部を含みます。インターネット上のどのAPIにもこの方法でアクセスできます。`__callback(bytes32 myid, string result)` 関数はコントラクトに結果を送信するために使われます。この関数の最初のパラメータ `myid`は最初の関数に保存されていて、その後、結果を前のリクエストにリンクするために使用されます。 17行目では、呼び出し元のエンティティが実際にオラクルであることを確認しています。その後、結果は18行目のストレージに保存されます。


## 結論

オラクルパターンを適用することの最も重要な点は、ブロックチェーンでは利用できないデータへのアクセスを得ることであり、それゆえビジネスモデルとユースケースをまったく新しい形で利用可能にすることです。 Webから任意のデータを提供するほかに、oraclesを使用して、クエリに時間遅延パラメータを指定することで、将来の指定された時刻に自動的に機能を起動することができます。これにより、ブロックチェーンで関数呼び出しをスケジュールする方法についてよくある問題を解決できます。 [Randomness pattern](./randomness.md)で説明されているように、乱数を生成するためにもよく使用されます。これは難しい作業です。開発者の観点からは、特に既存のサービスの1つを使用している場合は、Oracleパターンを実装するのはかなり簡単です。既存のソリューションを使用することのもう1つの利点は、これらのソリューションが厳重に監査され、エラーのリスクが軽減されることです。

オラクルの使用によるマイナスの影響は、単一障害点の導入です。契約の作成者および契約と対話するユーザーは、オラクルによって提供される情報に大きく依存しています。 オラクルとそのデータソースは過去に誤ったデータを報告しており、今後またエラーが発生する可能性があります。エラーだけでなく、提供されたデータの形式の小さな変更でも[redditで公開されている事例](https://www.reddit.com/r/ethtrader/comments/6w5wcn/important_update_mayweathermcgregor_smart_contract)のようにスマートコントラクトを破壊する可能性があります。ある時点でデータソースは出力のフォーマットを小文字から大文字に変更しました、その結果スマートコントラクトは処理を行うことができませんでした。もう一つの悪い結果は、オラクルとデータソースの両方に信頼を置く必要があることです。地方分権化を目指す環境では、単一の外部エンティティに頼ることは矛盾するように思われます。この問題は、要求を2つの独立したオラクルに転送することで軽減できる可能性があります。その結果は比較され評価されます。考えられる戦略は、Ｍ個の独立したオラクルを使用し、Ｍ人のエージェントのうち少なくともＮ人（Ｎ < Ｍ）によって報告された結果のみを受け入れることであり得る。このアプローチの欠点は、追加のオラクルが発生するたびにコストが増加することです。また、N個の応答を待つ必要があるため、ほとんどの場合、結論に至るまでの時間が長くなります。オラクルからの信頼を軽減するもう1つの方法は、Oraclizeで使用されている[TLSNotary証明](https://tlsnotary.org/)です。 TLSNotaryを使用すると、Oraclizeは特定の時間に特定のWebサイトを訪問したことを証明でき、実際に提供された結果を受け取りました。これはOraclizeが希望する結果が得られるまで乱数を照会するのを妨げることはありませんが、要求されたデータが短期間変動しない場合は信頼できます。

将来的には、執筆時点で多くの作業が行われる分散型オラクルの採用により、さらなる信頼性の問題が解決される可能性があります。


## 既知の使われ方

オラクルパターンの使用は、ブロックチェーンのさまざまなコントラクトで見つけることができます。Oraclizeを使用する例は、飛行遅延データへのアクセスを得るためにオラクルが使用されている[Etherisc](https://github.com/etherisc/flightDelay/blob/master/contracts/FlightDelayPayout.sol)のコントラクトで見れます。フライトが遅れた場合、コントラクトはその後ユーザーに保険料を支払います。

他のOracleの実装は、スポーツギャンブルコントラクト[Ethersquares](https://github.com/ethersquares/ethersquares-contracts/blob/master/contracts/OwnedScoreOracle.sol)に見ることができます。この場合、　コントラクトオーナーは自らオラクルの役目を果たします。ユーザーは、投票メカニズムを使用して、所有者から提供された結果が正しいかどうかを確認できます。

[**< Back**](https://github.com/shunMB/solidity-patterns-ja/)
