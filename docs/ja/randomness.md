# Randomness

## 目的
ブロックチェーンの決定論的環境で定義された間隔の乱数を生成する。

## 動機
コンピュータシステム、特にEthereumのランダム性を達成するのは非常に困難です。ソフトウェアで真の乱数を生成することは困難であるか不可能でさえありますが、Ethereumにおける乱数のランダム性の必要性は高いです。これは、Ethereumブロックチェーンのスマートコントラクトの大部分がゲームとして分類されることがあるという事実があるからです。 Ethereumのランダム性に関する問題は、Ethereumが決定論的チューリングマシンであり、固有のランダム性が関与していないことです。大多数のマイナーは、コンセンサスを得るために取引を評価するときに同じ結果を得なければなりません。コンセンサスはブロックチェーン技術の柱の1つであり、ランダム性はすべてのノード間の相互合意が不可能であることを意味します。もう1つの問題は、ブロックチェーンの一般的な性質です。コントラクトの内部状態、およびブロックチェーンの全履歴は、一般に公開されています。したがって、安全なエントロピーの発生源を見つけることは困難です。最初に思いつくEthereumのランダム性の手がかりはブロックタイムスタンプにあるでしょう。しかし、ブロックタイムスタンプにも問題があります。それは、タイムスタンプがその親ブロックより古くない限り、マイナーの影響を受ける可能性があることです。ほとんどの場合、タイムスタンプは正しく修正されますが、マイナーが誤ったタイムスタンプから恩恵を受けるインセンティブを持っている場合、ランダムな関数の結果を不正確なタイムスタンプで操作するためにマイニングパワーを使用できます。

何らかの方法でこの制限を克服するいくつかの回避策が開発されました。それぞれ次のようなグループに分けられ、それぞれに利点と欠点があります。

* **Block hash PRNG** - 乱数発生源としてブロックハッシュを使う
* **Oracle RNG** - 乱数をオラクルで提供する。詳しくは[Oracleパターン](./oracle.md)から。
* **Collaborative PRNG** - ブロックチェーン内での乱数の合意生成

オラクルの使用は[それぞれのパターン](./ oracle.md)および共同PRNGの最も有名な例[Randao](https://github.com/randao/randao)で既に説明されているため、の章ではブロックハッシュを使って擬似乱数の生成に焦点を当てます。またオラクルを使用して乱数生成を行うことは積極的に開発されているわけではないことも確かです。オラクルRNGの使用とブロックハッシュPRNGの使用との間の考察は、この章の結論のセクションで論じられます。


## 適用範囲

Randomnessパターンを使用できるのは、
* ユーザーが予期不可能な乱数を生成したい場合
* 乱数生成に関する外部サービスを使用したくない場合
* 確実なランダム性を保証する乱数を生成する信頼できるエンティティがある場合
です。


## 想定するコントラクトの参加者

このパターンの参加者は、呼び出し元のコントラクト、信頼できるエンティティ、およびマイナーであり、エントロピーソースとしてブロックハッシュを使用しているブロックをマイニングします。コントラクトは、ブロックハッシュをグローバル変数として利用し、信頼できるエンティティによって提供されたシードと一緒にそれを使用して、ブロックがマイニングされるまで誰も知り得ない値を内部で計算します。


## 実装

このパターンの最も簡単な実装は、最新のブロックハッシュを使うことです。

```Solidity
// Randomness provided by this is predicatable. Use with care!
function randomNumber() internal view returns (uint) {
    return uint(blockhash(block.number - 1));
}
```

このように実装の解決策は実用的ではありません。以下の2つの問題点があります。
1. ブロックハッシュから導き出された乱数がマイナーの不利になるならば、マイナーは発見されたブロックの存在を留保することができます。これによって、マイナーはもちろんブロック報酬を失うでしょう。したがって、この問題は、乱数に依存する金銭的価値が現在のブロックの報酬として少なくとも比較的高い場合にのみ関係します。
2. もっと問題になるのは、 `block.number`はブロックチェーン上で利用可能な変数なので、どのユーザでも入力パラメータとして使えるということです。ギャンブルコントラクトの場合、ユーザーは自分の賭けの入力として `uint（blockhash（block.number  -  1）`）を使用して、常にゲームに勝利することができます。

マイナーによる干渉の可能性と乱数の予測を取り除くために、Bonneauたちは2015年にBitcoinに適用できる解決策を提案しました。信頼できる当事者は、将来のブロックハッシュとともにハッシュされるシードを提供し、マイナーが自分のブロックの結果を予測できないようにします。この乱数をハッシュします。悪意のあるマイナーによる妨害を避けることを目的としてRandomnessパターンにおいてはこのアイデアを使用しています。

信頼できる当事者はコントラクトオーナーが選択でき、コントラクトに記載されます。最初に、ユーザーは最初の段階でコントラクトとのやりとりをすることができます。信頼できる当事者による暗号化されたシードの提出により、賭けはクローズされ、現在のブロック番号+1が保存されます。これは後で役に立ちます。シードは信頼できる当事者のアドレスと一緒にハッシュすることで暗号化できます。これにより、次のステップで簡単に検証できます。

シードが格納された後、信頼できる当事者は、シードが明らかになるまで少なくとも1ブロック待たなければなりません。もちろん、暗号化されたシードを実際のシードのハッシュおよび信頼される側のアドレスと比較することによって、コミットされたハッシュが現在提供されているシードのハッシュの結果であることを検証する必要があります。この場合、シードは受け入れられ、記憶されているブロック番号と一緒にハッシュされて疑似乱数を生成することができます。シードは平文で送信されるため、現在のブロック番号を使用するとマイナーからの差し控えによる干渉が発生する可能性があるため、前の手順で格納したブロック番号を使用します。それを格納する前のブロック番号の増分で、私たちは将来のブロックハッシュがエントロピーのソースとして使われることを確実にしています、信頼できるパーティーがそれを予測することを不可能にします。

乱数が特別な間隔であると想定される場合には、剰余関数を利用することができます。必要な長さに応じて、取得したハッシュの最後の部分だけが使用されます。


## サンプルコード

提供されているサンプルでは、​​ギャンブルコントラクトのコンテキストで信頼できるエンティティを使用して疑似乱数ジェネレータを実装しています。このことを明確にするために、賭けプロセスに関するすべてのロジックは省略しています。
```Solidity
// This code has not been professionally audited, therefore I cannot make any promises about
// safety or correctness. Use at own risk.
contract Randomness {

    bytes32 sealedSeed;
    bool seedSet = false;
    bool betsClosed = false;
    uint storedBlockNumber;
    address trustedParty = 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF;

    function setSealedSeed(bytes32 _sealedSeed) public {
        require(!seedSet);
        require (msg.sender == trustedParty);
        betsClosed = true;
        sealedSeed = _sealedSeed;
        storedBlockNumber = block.number + 1;
        seedSet = true;
    }

    function bet() public {
        require(!betsClosed);
        // Make bets here
    }

    function reveal(bytes32 _seed) public {
        require(seedSet);
        require(betMade);
        require(storedBlockNumber < block.number);
        require(keccak256(msg.sender, _seed) == sealedSeed);
        uint random = uint(keccak256(_seed, blockhash(storedBlockNumber)));
        // Insert logic for usage of random number here;
        seedSet = false;
        betsClosed = false;
    }
}
```
信頼されたエンティティはコントラクトの7行目にハードコードされています。[アクセス制限パターン](./access_restriction.md)によって不正アクセスから保護されたセッター機能を使用してコントラクトオーナーによる信頼されたエンティティの変更を許可するオプションです。ユーザは関数 `bet()`を呼び出すことによって彼らの賭けをすることができます。ハッシュ化されたシードは、 `setSealedSeed(bytes32 _sealedSeed)`を呼び出すことで、信頼できる側と信頼できる側だけが設定できます（11行目）。関数の実行で、暗号化されたシードとインクリメントされた現在のブロック番号が格納され、 `seedSet`ブール値がtrueに設定され、シードが2回目の関数呼び出しによって上書きされるのを防ぎます。さらに、乱数を生成するために使用されたシードまたはブロックハッシュについて学んだ後に信頼できるエンティティまたはマイナーが彼らの賭けをプッシュすることを回避するために、賭けはクローズされます。

暗号化シードを提供してから少なくとも1ブロックが経過した後、信頼されたエンティティは23行目で `reveal(bytes32 _seed)`を呼び出すことでシードを明らかにできます。24-27行目は[Guard Checkパターン](./ guard_check)を実装します。そして、封印されたシードが設定された後にのみシードが明らかにされることができることを確実にし（24行目）、依拠するアクションが実行され（25行目）、参照しているブロックはマイニングされます（26行目）。信頼できるエンティティが暗号化されたシードと一致するシードを提供できる唯一のエンティティである必要があるため、信頼できるエンティティに対するアクセス制限を実装することはできますが、必須ではありません。これは２７行目で検証され、そこで信頼されたエンティティによって提供されたシードが、前のステップでコミットされたものと実際に同じであったかどうかがチェックされる。実際の乱数は、28行目で、以前に格納された数のブロックのハッシュとともにシードをハッシュすることによって生成されます。次のステップは、勝者の払い出しのように、数字を任意の間隔にフォーマットし、乱数を使用して任意のロジックを実行することです。


## 結論

Randomnessパターンの結果は、Kofler（2016）によると以下の基準に従って評価できます。
* **ランダム性** - 達成されたランダム性はどのくらい良いですか？それは疑似または真のランダム性ですか？
* **セキュリティ** - 乱雑性を生成するために使用される方法はどの程度安全ですか？
* **コスト** -  ランダム数の生成に関連するコストはどのくらいですか？
* **時間遅延** - 乱数の要求から受信までの時間遅延はどのくらいですか？

提案された方法で生成された値は擬似乱数です。ブロックハッシュとシードは決定論的な方法で提供され、両方の入力パラメータがわかっていれば、結果は予測できます。ただし、2つの異なるソースからのブロックハッシュとシードの組み合わせ、および両方のソースが他方を学習する前に入力をコミットする必要があるため、実際には乱数に影響を与えることは不可能です。

ここで乱数が得られたら、それは安全であると見なすことができます。唯一の不安は信頼できるエンティティによってもたらされます。信頼できるエンティティという表現は、そのエンティティを盲目的に信頼しなければならないという意味ではありません。それどころか、取られる対策は、信頼できるエンティティにとっても、乱数を操作することを不可能にします。提供されたシードを明らかにするためにそれを信頼するだけでよいのです。シードは暗号的に安全な方法で暗号化されているため、信頼できるエンティティなしでシードを入手することは現在不可能です。さらに、Ethereumブロックチェーンでは、最新の256ブロックへのアクセスのみが許可されます。つまり、信頼できるエンティティは、格納されているブロック番号を取得できなくなる前にシードを公開する必要があります。ユーザーが自分の資金を回収することを可能にするためのメカニズムは、実装されるべきです。つまり、このパターンが実装された状態で不正を行う唯一の方法は、信頼される側が明らかにされたシードを差し控えること、またはセルフィッシュマイニングや他のマイナーと共謀し、信頼される側がハッシュを使用しているブロックのブロック作成に影響を与える可能性がある場合のみです

この方法のコストは、外部サービスを支払う必要がないため、比較的低くなります。しかしながら、より多くのトランザクションとストレージが必要となるため、信頼できるエンティティを使用するガス代は、単純な場合と比べて高くなります。

この結果を[Oracleパターン](./ oracle.md)の場合と比較すると、それらの違いを簡単に実感できます。真の乱数を提供するサービスから数字を問い合わせることができるので、オラクルによって提供される乱数は真の乱数になることができます。この例では1つの当事者だけを信頼する必要がありますが、オラクルと対話するときは2つの当事者、つまりデータプロバイダとオラクルサービスを信頼する必要があります。もう1つの違いは、リクエストごとにOracleサービスを支払う必要があることです。オラクルソリューションで発生する遅延は、上記で提案したものと同等です。

経済的な影響がない単純なコントラクトでは、シードなしのブロックハッシュのランダム性の単純なコンセンサスで十分であると結論付けることができます。しかし、より高い利害関係を持つユースケースのためには、オラクルサービスまたはシードが関連付けられた解決策が使用されることになります。このとき、信頼できるエンティティの存在を考慮することが大切です。

 
## 既知の使われ方
Rondomnessパターンは、ゲームやギャンブルのコントラクトでよく使用されます。将来のブロックハッシュとシードによる実装は、[Cryptogsコントラクト](https://etherscan.io/address/0xeFabE332D31c3982B76F8630a306C960169bD5b3\#code)で確認することができます。 このときオラクルを使用しないように、commit/revealスキームが採用されています。
しかし、[彼らによると](https://medium.com/coinmonks/is-block-blockhash-block-number-1-okay-14a28e40cc4b)このcommit/revealスキームによるセキュリティは、単純な実装と比較して、あまり価値がありません。
また、追加のトランザクションに関連する追加の時間とコストは、それらが処理している金額とは関係ありません。

信頼というものは考えるに値する問題ですが、多くのコントラクトでは、乱数にアクセスするためにオラクルのサービスを使用しているようです。実際に観察されたものはすべて彼らのサービスとしてOraclizeを使っていました。 Oraclizeがその数を手に入れている実際のランダム性のソースは、より不均一です。 random.orgとOraclizeを組み合わせて使用したコントラクトの例は[vDice](https://etherscan.io/address/0x7DA90089A73edD14c75B0C827cb54f4248D47eCc\#code)です。 Oraclizeのサービスに依存している他の契約は[Pray4Prey](https://etherscan.io/address/0xe648ae88a6d9b3373e115e3414be91b7cf12de4c\#code)です。 vDiceとは対照的に、WolframAlphaでは乱数が生成されます。

一般的な印象として、単純なコントラクトはブロックハッシュに依存して外部通信を回避する傾向がありますが、より洗練されたコントラクトやより大きな賭け金を扱う契約はオラクルのサービスを使用する可能性が高いようです。

[**< Back**](https://github.com/shunMB/solidity-patterns-ja/)
